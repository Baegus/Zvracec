<!DOCTYPE html>
<html lang="cs">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Zvraceč</title>
	<meta name="description" content="Text a zvuk pozpátku. Napiš, převrať, nahraj, stahuj!">
	<meta name="author" content="Baegus">
	<meta name="keywords" content="převrátit, pozpátku, reverse, text, zvuk, audio, nahrát, mikrofon, mp3, foneticky, česky, čtení pozpátku, záznamník">
	<link rel="icon" type="image/x-icon" href="icon-192.png">
	<link rel="manifest" href="manifest.json">
	<meta name="theme-color" content="#e9dc2a">
	<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
	<style>
		:root {
			--bg-color: #121212;
			--surface-color: #1e1e1e;
			--text-color: #e0e0e0;
			--accent-color: #e9dc2a;
		}

		body {
			background-color: var(--bg-color);
			color: var(--text-color);
			font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
			margin: 0;
			padding: 14px;
			display: flex;
			flex-direction: column;
			align-items: center;
			min-height: 100vh;
		}

		h1 {
			color: var(--accent-color);
			margin-top: 5px;
			margin-bottom: 0px;
			text-transform: uppercase;
			letter-spacing: 2px;
			text-align: center;
		}

		.flip-letter {
			display: inline-block;
			transform-style: preserve-3d;
		}

		.description {
			text-align: center;
			margin-bottom: 25px;
			font-size: 1rem;
			color: #ccc;
		}

		.container {
			width: 100%;
			max-width: 600px;
			display: flex;
			flex-direction: column;
			gap: 15px;
		}

		/* Settings section */
		.settings {
			background-color: var(--surface-color);
			padding: 15px;
			border-radius: 8px;
			display: flex;
			flex-direction: column;
			gap: 12px;
			border-left: 3px solid var(--accent-color);
		}

		label {
			display: flex;
			align-items: center;
			gap: 10px;
			cursor: pointer;
			font-size: 0.95rem;
			user-select: none;
		}

		input[type="checkbox"] {
			accent-color: var(--accent-color);
			width: 20px;
			height: 20px;
			cursor: pointer;
		}

		/* Text area */
		textarea {
			width: 100%;
			height: 120px;
			max-height: calc(100svh - 130px);
			background-color: var(--surface-color);
			color: var(--text-color);
			border: 1px solid #333;
			border-radius: 8px;
			padding: 15px;
			font-size: 1.2rem;
			line-height: 1.4;
			resize: vertical;
			box-sizing: border-box;
			outline: none;
			transition: border-color 0.2s;
		}

		textarea:focus {
			border-color: var(--accent-color);
		}

		#input-text {
			font-size: 1rem;
		}

		#output-text {
			background-color: #000;
			border: 1px dashed var(--accent-color);
			color: var(--accent-color);
			font-weight: 500;
		}

		/* Audio section */
		.audio-section {
			margin-top: 10px;
			padding: 20px 15px;
			border-radius: 8px;
			background-color: rgba(255, 255, 255, 0.03);
			text-align: center;
		}

		.btn-group {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			justify-content: center;
			margin-top: 10px;
			width: 100%;
		}

		button {
			background-color: var(--surface-color);
			color: var(--text-color);
			border: 1px solid var(--accent-color);
			padding: 12px 10px;
			padding-left: 25px;
			border-radius: 6px;
			font-size: 0.9rem;
			cursor: pointer;
			transition: all 0.2s;
			text-transform: uppercase;
			font-weight: bold;
			min-width: 80px;
			flex: 1;
			display: inline-flex;
			align-items: center;
			justify-content: center;
			gap: 8px;
			position: relative;
		}

		button:active {
			transform: scale(0.96);
		}

		button.primary {
			background-color: var(--accent-color);
			color: #000;
			/* Black text on light accent color */
		}

		button:disabled {
			opacity: 0.4;
			cursor: not-allowed;
			border-color: #555;
			background-color: transparent;
			color: #777;
		}

		.status {
			height: 20px;
			font-size: 0.9rem;
			color: var(--accent-color);
			margin-bottom: 5px;
			font-style: italic;
		}

		/* --- ICONS --- */
		.icon {
			display: inline-block;
			flex-shrink: 0;
			position: absolute;
			left: 8px;
		}

		/* Record: Red Circle */
		.icon-record {
			width: 10px;
			height: 10px;
			background-color: #ff4757;
			border-radius: 50%;
			box-shadow: 0 0 0 2px rgba(255, 71, 87, 0.3);
		}

		.icon-record {
			position: static;
		}

		/* Stop: Square */
		.icon-stop {
			width: 10px;
			height: 10px;
			background-color: currentColor;
			border-radius: 1px;
		}

		/* Play: Triangle Right */
		.icon-play,
		.icon-play-reverse {
			width: 0;
			height: 0;
			border-style: solid;
			border-width: 5px 0 5px 8px;
			border-color: transparent transparent transparent currentColor;
		}

		/* Play Reverse: Triangle Left */
		.icon-play-reverse {
			transform: scaleX(-1);
		}

		/* Download: Arrow Down */
		.icon-download {
			width: 12px;
			height: 12px;
			left: 7px;
		}

		.icon-download::before {
			content: "";
			position: absolute;
			top: 0;
			left: 4px;
			width: 4px;
			height: 8px;
			background-color: currentColor;
		}

		.icon-download::after {
			content: "";
			position: absolute;
			bottom: 0;
			left: 0;
			width: 0;
			height: 0;
			border-left: 6px solid transparent;
			border-right: 6px solid transparent;
			border-top: 6px solid currentColor;
		}

		@media(max-width: 480px) {
			button {
				font-size: 0.8rem;
			}

			#output-text {
				font-size: 1.05rem;
			}
		}
	</style>
</head>

<body>

	<h1>Zvraceč</h1>
	<p class="description">Text a zvuk pozpátku. Napiš, převrať, nahraj, stahuj!</p>

	<div class="container">
		<!-- Settings -->
		<div class="settings">
			<label><input type="checkbox" id="chk-reverse" checked>Převrátit text (Pivo → oviP apod.)</label>
			<label><input type="checkbox" id="chk-phonetic" checked>Foneticky upravit (č → ťš, mě → mňe apod.)</label>
			<label><input type="checkbox" id="chk-split">Rozdělit dlouhá slova (snazší čitelnost)</label>
			<label><input type="checkbox" id="chk-upper">VŠECHNO VELKÝMI</label>
			<label><input type="checkbox" id="chk-lower">všechno malými</label>
		</div>

		<!-- Input / Output -->
		<textarea id="input-text" placeholder="Sem napiš text..."></textarea>
		<textarea id="output-text" placeholder="Výsledek..." readonly></textarea>

		<!-- Audio section -->
		<div class="audio-section">
			<div class="status" id="audio-status"></div>

			<div class="btn-group">
				<button id="btn-record" class="primary"><span class="icon icon-record"></span> Nahrát</button>
			</div>

			<div class="btn-group">
				<button id="btn-play" disabled><span class="icon icon-play"></span> Přehrát</button>
				<button id="btn-play-reverse" disabled><span class="icon icon-play-reverse"></span> Přehrát pozpátku</button>
			</div>

		<div class="btn-group">
			<button id="btn-download" disabled><span class="icon icon-download"></span> Stáhnout MP3</button>
			<button id="btn-download-reverse" disabled><span class="icon icon-download"></span> Stáhnout MP3 pozpátku</button>
		</div>

		<div class="btn-group">
			<button id="btn-install" style="display: none;">Nainstalovat offline</button>
		</div>
	</div>
</div>
<script>
	const getID = id => document.getElementById(id);
	/* --- TEXT SECTION --- */
	const inputText = getID("input-text");
	const outputText = getID("output-text");

	const chkPhonetic = getID("chk-phonetic");
	const chkReverse = getID("chk-reverse");
	const chkSplit = getID("chk-split");
	const chkUpper = getID("chk-upper");
	const chkLower = getID("chk-lower");

	// Textarea auto-resize variables
	let userResizedOutput = false;
	let lastAutoHeight = 0;

	// Detect if user manually resized the textarea
	window.addEventListener("pointerup", function () {
		if (lastAutoHeight == 0 || outputText.offsetHeight == lastAutoHeight) return;
		// User probably resized the textarea manually
		userResizedOutput = true;
	});

	function setTextareaHeight(textarea) {
		if (userResizedOutput) return;
		outputText.style.height = "120px";

		const newHeight = Math.max(120, outputText.scrollHeight + 2);
		outputText.style.height = `${newHeight}px`;
		lastAutoHeight = outputText.offsetHeight;
	}

	// Map for phonetic replacements (lowercase only)
	const phoneticMap = [
		["č", "ťš"],
		["c(?!h)", "ts"],
		["x", "ks"],
		["q", "kv"],
		["ch", "hc"],
		["tě", "ťe"],
		["mě", "mňe"],
		["ně", "ňe"],
		["dě", "ďe"],
		["pě", "pje"],
		["vě", "vje"],
		["bě", "bje"],
		["fě", "fje"],
		["di", "ďy"],
		["ti", "ťy"],
		["ni", "ňy"],
		["dí", "ďý"],
		["tí", "ťý"],
		["ní", "ňý"],
		["it", "yt"],
		["ít", "ýt"],
		["id", "yd"],
		["íd", "ýd"],
		["in", "yn"],
		["ín", "ýn"],
		["íd", "ýd"],
	];

	// Caps/Lower checkbox control
	chkUpper.addEventListener("change", () => { if (chkUpper.checked) chkLower.checked = false; processText(); });
	chkLower.addEventListener("change", () => { if (chkLower.checked) chkUpper.checked = false; processText(); });

	[chkPhonetic, chkReverse, chkSplit, inputText].forEach(el => {
		el.addEventListener("input", processText);
		el.addEventListener("change", processText);
	});

	// Helper: Preserve letter case when replacing
	function matchCase(text, pattern) {
		// If pattern is all UPPERCASE (more than 1 char and all caps) -> return text in uppercase
		if (pattern.length > 1 && pattern === pattern.toUpperCase()) {
			return text.toUpperCase();
		}
		// If first letter of pattern is uppercase -> Capitalize
		if (pattern[0] === pattern[0].toUpperCase()) {
			return text.charAt(0).toUpperCase() + text.slice(1);
		}
		// Otherwise lowercase
		return text.toLowerCase();
	}

	function processText() {
		let txt = inputText.value;

		// Phonetic adjustment (Before case change, but with case detection)
		if (chkPhonetic.checked) {
			// Replace "v" with "f" at the end of words
			txt = txt.replace(/v(?![a-z\u00C0-\u024F])/gi, (match) => {
				return match === "V" ? "F" : "f";
			});
			phoneticMap.forEach(([search, replace]) => {
				if (search == "ch" && !chkReverse.checked) return;
				const regex = new RegExp(search, "gi");
				txt = txt.replace(regex, (match) => {
					return matchCase(replace, match);
				});
			});
		}

		// Case transformation (global)
		if (chkUpper.checked) txt = txt.toUpperCase();
		if (chkLower.checked) txt = txt.toLowerCase();

		// Split long words
		if (chkSplit.checked) {
			txt = txt.replace(/\S{7,}/g, (word) => {
				const mid = Math.floor(word.length / 2);
				return word.slice(0, mid) + "-" + word.slice(mid);
			});
		}

		// Reverse text
		if (chkReverse.checked) {
			txt = txt.split("").reverse().join("");
		}

		outputText.value = txt.trim();
		setTextareaHeight(outputText);
	}


	/* --- AUDIO SECTION --- */
	let mediaRecorder;
	let audioChunks = [];
	let audioCtx;
	let currentBuffer = null;
	let reversedBuffer = null;
	let isRecording = false;
	let currentAudioSource = null; // Track currently playing audio source

	const btnRecord = getID("btn-record");
	const btnPlay = getID("btn-play");
	const btnPlayReverse = getID("btn-play-reverse");
	const btnDownload = getID("btn-download");
	const btnDownloadReverse = getID("btn-download-reverse");
	const statusEl = getID("audio-status");

	const statusMessages = {
		ready: "Připraveno nahrávat mikrofonem",
		recording: "Nahrávám...",
		processing: "Zpracovávám...",
		processed: "Nahrávka připravena",
		error: "Chyba zpracování nahrávky",
		playback: "Přehrávám...",
		mp3conversion: "Konvertuji do MP3...",
	}

	const setStatus = (status) => {
		statusEl.textContent = statusMessages[status] || "";
	}
	setStatus("ready");

	function initAudio() {
		if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
	}

	let currentStream = null;

	btnRecord.addEventListener("click", async () => {
		initAudio();
		if (audioCtx.state === "suspended") await audioCtx.resume();

		if (!isRecording) {
			// START RECORDING
			try {
				// Capture the stream into a global variable
				currentStream = await navigator.mediaDevices.getUserMedia({
					audio: {
						echoCancellation: false,
						noiseSuppression: false,
						autoGainControl: false,
						channelCount: 1
					}
				});

				mediaRecorder = new MediaRecorder(currentStream);
				audioChunks = [];

				mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
				mediaRecorder.onstop = processRecording;

				mediaRecorder.start();
				isRecording = true;
				btnRecord.innerHTML = `<span class="icon icon-stop"></span> STOP`;
				btnRecord.style.backgroundColor = "#ff4757";
				btnRecord.style.color = "#fff";
				btnRecord.style.borderColor = "#ff4757";
				setStatus("recording");
				disableAudioControls(true);
			} catch (err) {
				alert("Chyba mikrofonu: " + err.message);
			}
		} else {
			// STOP RECORDING
			mediaRecorder.stop();
			isRecording = false;
			if (currentStream) {
				currentStream.getTracks().forEach(track => track.stop());
				currentStream = null;
			}
			btnRecord.innerHTML = `<span class="icon icon-record"></span> Nahrát`;
			btnRecord.removeAttribute("style");
			setStatus("processing");
		}
	});

	async function processRecording() {
		try {
			const blob = new Blob(audioChunks, { type: "audio/webm" });
			const arrayBuffer = await blob.arrayBuffer();
			currentBuffer = await audioCtx.decodeAudioData(arrayBuffer);

			normalizeBuffer(currentBuffer);

			// Create reversed buffer (Now using the already normalized data)
			reversedBuffer = audioCtx.createBuffer(
				currentBuffer.numberOfChannels,
				currentBuffer.length,
				currentBuffer.sampleRate
			);
			for (let i = 0; i < currentBuffer.numberOfChannels; i++) {
				const src = currentBuffer.getChannelData(i);
				const dest = reversedBuffer.getChannelData(i);
				dest.set(src);
				Array.prototype.reverse.call(dest);
			}

			setStatus("processed");
			enableAudioControls();
		} catch (e) {
			console.error(e);
			setStatus("error");
		}
	}

	function normalizeBuffer(buffer) {
		const maxChannels = buffer.numberOfChannels;
		let maxPeak = 0;

		// Find the loudest peak in the entire recording
		for (let i = 0; i < maxChannels; i++) {
			const channelData = buffer.getChannelData(i);
			for (let j = 0; j < channelData.length; j++) {
				const abs = Math.abs(channelData[j]);
				if (abs > maxPeak) {
					maxPeak = abs;
				}
			}
		}

		// Calculate amplification factor (target 0.99 to avoid clipping)
		// If the audio is silent (maxPeak 0), don't do anything.
		if (maxPeak === 0) return;
		const amplification = 0.99 / maxPeak;

		// Apply amplification if the audio is quiet
		// (Only boost if we are actually increasing volume)
		if (amplification > 1) {
			for (let i = 0; i < maxChannels; i++) {
				const channelData = buffer.getChannelData(i);
				for (let j = 0; j < channelData.length; j++) {
					channelData[j] *= amplification;
				}
			}
		}
	}

	function playBuffer(buffer) {
		if (!buffer) return;

		// Stop any currently playing audio
		if (currentAudioSource) {
			try { currentAudioSource.stop(); } catch (e) { }
			currentAudioSource = null;
		}

		// Create Source
		const source = audioCtx.createBufferSource();
		source.buffer = buffer;

		// Create a Compressor (The "Limiters" that prevents distortion)
		// This pushes down loud peaks so we can boost the overall volume safely
		const compressor = audioCtx.createDynamicsCompressor();
		compressor.threshold.value = -24;  // Start compressing early
		compressor.knee.value = 30;        // Smooth transition
		compressor.ratio.value = 12;       // Heavy compression ratio
		compressor.attack.value = 0.003;   // Fast attack to catch peaks
		compressor.release.value = 0.25;   // Fast release

		// Create a Pre-Amp Gain (The Volume Boost)
		const gainNode = audioCtx.createGain();
		// boost the volume (to prevent Firefox/iOS being too quiet)
		gainNode.gain.value = 5.0;

		// Connect the chain: Source -> Gain -> Compressor -> Speakers
		source.connect(gainNode);
		gainNode.connect(compressor);
		compressor.connect(audioCtx.destination);

		source.start(0);
		currentAudioSource = source;

		setStatus("playback");
		source.onended = () => {
			setStatus("processed");
			currentAudioSource = null;
		};
	}

	btnPlay.addEventListener("click", () => playBuffer(currentBuffer));
	btnPlayReverse.addEventListener("click", () => playBuffer(reversedBuffer));

	function downloadBuffer(buffer, filename) {
		if (!buffer) return;
		statusEl.textContent = "Konvertuji do MP3...";

		setTimeout(() => { // Timeout to allow status to redraw
			const mp3Blob = bufferToMp3(buffer);
			const url = URL.createObjectURL(mp3Blob);
			const a = document.createElement("a");
			a.style.display = "none";
			a.href = url;
			a.download = filename;
			document.body.appendChild(a);
			a.click();
			window.URL.revokeObjectURL(url);
			setStatus("processed");
		}, 50);
	}

	btnDownload.addEventListener("click", () => downloadBuffer(currentBuffer, "zvracec_zaznam.mp3"));
	btnDownloadReverse.addEventListener("click", () => downloadBuffer(reversedBuffer, "zvracec_zaznam_pozpatku.mp3"));

	function disableAudioControls(all) {
		btnPlay.disabled = true;
		btnPlayReverse.disabled = true;
		btnDownload.disabled = true;
		btnDownloadReverse.disabled = true;
		if (all) btnRecord.disabled = false;
	}

	function enableAudioControls() {
		btnPlay.disabled = false;
		btnPlayReverse.disabled = false;
		btnDownload.disabled = false;
		btnDownloadReverse.disabled = false;
	}

	// --- MP3 ENCODING LOGIC (LAMEJS) ---
	function bufferToMp3(buffer) {
		const channels = buffer.numberOfChannels;
		const sampleRate = buffer.sampleRate;
		const mp3Encoder = new lamejs.Mp3Encoder(channels, sampleRate, 320); // 320kbps

		// Get data (Float32) and convert to Int16
		// Lamejs needs Int16. Web Audio API provides Float32 (-1.0 to 1.0)
		const left = convertFloat32ToInt16(buffer.getChannelData(0));
		const right = channels > 1 ? convertFloat32ToInt16(buffer.getChannelData(1)) : undefined;

		const sampleBlockSize = 1152;
		const mp3Data = [];

		// Encode in chunks
		for (let i = 0; i < left.length; i += sampleBlockSize) {
			const leftChunk = left.subarray(i, i + sampleBlockSize);
			let mp3buf;

			if (channels === 2 && right) {
				const rightChunk = right.subarray(i, i + sampleBlockSize);
				mp3buf = mp3Encoder.encodeBuffer(leftChunk, rightChunk);
			} else {
				mp3buf = mp3Encoder.encodeBuffer(leftChunk);
			}

			if (mp3buf.length > 0) {
				mp3Data.push(mp3buf);
			}
		}

		// Finish encoding
		const mp3buf = mp3Encoder.flush();
		if (mp3buf.length > 0) {
			mp3Data.push(mp3buf);
		}

		return new Blob(mp3Data, { type: "audio/mp3" });
	}

	function convertFloat32ToInt16(float32Array) {
		const int16Array = new Int16Array(float32Array.length);
		for (let i = 0; i < float32Array.length; i++) {
			// Clamp values between -1 and 1
			let val = Math.max(-1, Math.min(1, float32Array[i]));
			// Conversion: 0x7FFF = 32767
			int16Array[i] = val < 0 ? val * 0x8000 : val * 0x7FFF;
		}
		return int16Array;
	}

	// --- LOCALSTORAGE: Save & Load Settings ---
	const STORAGE_KEY = "zvracec_state";

	function saveToLocalStorage() {
		const state = {
			inputText: inputText.value,
			chkReverse: chkReverse.checked,
			chkPhonetic: chkPhonetic.checked,
			chkSplit: chkSplit.checked,
			chkUpper: chkUpper.checked,
			chkLower: chkLower.checked
		};
		localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
	}

	function loadFromLocalStorage() {
		try {
			const savedState = localStorage.getItem(STORAGE_KEY);
			if (savedState) {
				const state = JSON.parse(savedState);
				inputText.value = state.inputText || "";
				chkReverse.checked = state.chkReverse !== undefined ? state.chkReverse : true;
				chkPhonetic.checked = state.chkPhonetic !== undefined ? state.chkPhonetic : true;
				chkSplit.checked = state.chkSplit || false;
				chkUpper.checked = state.chkUpper || false;
				chkLower.checked = state.chkLower || false;
			}
		} catch (e) {
			console.error("Error loading from localStorage:", e);
		}
	}

	// Load saved state on page load
	loadFromLocalStorage();

	// Save to localStorage whenever input or settings change
	inputText.addEventListener("input", saveToLocalStorage);
	[chkPhonetic, chkReverse, chkSplit, chkUpper, chkLower].forEach(el => {
		el.addEventListener("change", saveToLocalStorage);
	});

	// Run initial text processing
	processText();

	// Register Service Worker
	if ("serviceWorker" in navigator) {
		window.addEventListener("load", () => {
			navigator.serviceWorker.register("./worker.js")
				.then(registration => {
					console.log(`ServiceWorker registration successful with scope: ${registration.scope}`);
				}, err => {
					console.log(`ServiceWorker registration failed: ${err}`);
				});
		});
	}

	// PWA Install functionality
	let deferredPrompt;
	const btnInstall = getID("btn-install");

	window.addEventListener("beforeinstallprompt", (e) => {
		// Prevent the mini-infobar from appearing on mobile
		e.preventDefault();
		// Stash the event so it can be triggered later
		deferredPrompt = e;
		// Show the install button
		btnInstall.style.display = "inline-flex";
	});

	btnInstall.addEventListener("click", async () => {
		if (!deferredPrompt) {
			return;
		}
		// Show the install prompt
		deferredPrompt.prompt();
		// Wait for the user to respond to the prompt
		const { outcome } = await deferredPrompt.userChoice;
		console.log(`User response to the install prompt: ${outcome}`);
		// Clear the deferredPrompt so it can only be used once
		deferredPrompt = null;
		// Hide the install button
		btnInstall.style.display = "none";
	});

	window.addEventListener("appinstalled", () => {
		// Hide the install button when app is installed
		btnInstall.style.display = "none";
		deferredPrompt = null;
	});

	// H1 Animation
	function setupH1Animation() {
		const h1 = document.querySelector("h1");
		if (!h1) return;

		const text = h1.textContent;
		h1.innerHTML = "";
		[...text].forEach(char => {
			const span = document.createElement("span");
			span.textContent = char;
			span.className = "flip-letter";
			h1.appendChild(span);
		});

		const letters = h1.querySelectorAll(".flip-letter");

		const keyframes = [
			{ transform: "rotateY(0deg)", offset: 0 },
			{ transform: "rotateY(180deg)", offset: 0.4 },
			{ transform: "rotateY(180deg)", offset: 0.6 },
			{ transform: "rotateY(0deg)", offset: 1 }
		];

		const duration = 1200;
		const stagger = 100; // delay per letter

		function animate() {
			letters.forEach(letter => {
				letter.getAnimations().forEach(anim => anim.cancel());
			});

			letters.forEach((letter, index) => {
				letter.animate(keyframes, {
					duration: duration,
					easing: "ease-in-out",
					delay: index * stagger,
					fill: "none"
				});
			});
		}

		setTimeout(() => {
			animate();
			setInterval(animate, 20_000);
		}, 600);
	}
	setupH1Animation();
</script>
</body>
</html>